一.JVM简介
虚拟机：VMware/Virtual  Box
通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。


JVM是通过软件模拟Java字节码指令集，JVM只保存了PC寄存器，而普遍的虚拟机有很多寄存器。

从JDK1.3至今，HotSpot为默认JVM

JVM可以跑很多语言：Scala，Koltin

二.Java的内存区域划分---共六块内存


JVM内存划分－》判断对象是否存活－＞垃圾回收算法－》垃圾回收器－》JVM性能检测

3.1线程私有内存：每个线程都有，彼此之间完全隔离。
3.1.1程序计数器
程序计数器是比较小的内存空间，当前线程所执行的字节码的行号指示器。

字节码的行号指示器

单核CPU：每一个具体时刻只有一个线程抢占CPU资源。


若当前线程执行的是加Java方法，计数器记录的是正在执行的JVM字节码指令地址。
若当前线程执行的是native方法，计数器值为空。

程序计数器是唯一一块不会产生OOM异常的区域。

3.1.2虚拟机栈：Java方法执行的内存模型
虚拟机栈描述Java方法执行的内存模型。

每个方法的执行同时都会创建一个栈帧来存储局部变量表，操作数栈，方法出口等信息，每个方法从调用知道执行完毕的过程，对应一个栈帧在虚拟机的入栈和出栈过程。

生命周期与线程相同：在创建线程的同时创建线程的虚拟机栈，线程执行结束，虚拟机栈与线程一同被收回。


对象引用：四个字节

此区域一共会产生两种异常：
１.若线程请求的栈的深度大于JVM允许的深度（-Xss设置栈容量），抛出StackOverflowError异常。（递归，如果递归层数很深，会栈溢出）（常见于单线程）
２.虚拟机在进行栈的动态扩展时，若无法申请到足够内存，抛出OOM （OutOfMemoryError）异常　（常见于多线程 ）

3.1.3本地方法栈：
本地方法（native方法）执行的内存模型。

HotSpot虚拟机中，本地方法栈与虚拟机栈是同一块内存区域。


3.2线程共享内存：所有线程共享此内存空间，对空间所有的线程可见

3.2.1堆（GC堆）
Java堆（Java　Heap）是JVM管理的最大内存区域。在JVM启动时创建。所有线程共享此内存，此内存中存放的是对象实例以及数组。

Java堆是垃圾回收器管理的最主要的内存区域。Java堆可以处于物理上不连续的内存空间。
－Ｘｍｘ设置堆最大值
－Xms设置堆最小值

异常：
若在堆中没有足够的内存完成对象实例分配且堆无法再次扩展时。抛出OOM异常

OOM：

内存溢出：内存中的对象确实还应该存活，但是由于堆内存不够产生的异常。
内存泄漏：无用对象无法被GC


3.2.2方法区
用于存储JVM加载的类信息，常量，静态变量等数据。JDK１.８之前，方法区也叫永久代，JDK１.８之后称为元空间（Meta　Space）

方法区无法满足内存分配需求时，抛出OOM异常

3.2.3运行时常量池
运行时常量池方法区的一部分，存放字面量与符号引用。

字面量：字符串常量（JDK１.７移到堆中），final常量，基本数据类型的值。
符号引用：字段，类，方法的完全限定名（包名＋类名），名称，描述。

对象产生：符号引用－＞类－＞具体引用

4.判断对象是否存活
4.1引用计数法
算法思想：
给每一个对象附加一个引用计数器，每当有一个地方引用此对象，计数器加一，当有一个引用失效时，计数器减一。在任意时刻，只要计数器值为0,的对象就是不能再使用的，即对象已死。

引用计数法实现简单，效率也较高。Python使用引用计数法来管理内存。
但是无法解决循环引用问题。

JVM并没有采用此算法。

-XX：printGC：打印具体的垃圾回收日志

4.2可达性分析算法
Java采用可达性分析算法来判断对象是否存活）（C#，Lisp）
核心思想：
通过一系列“GC Roots”的对象作为起点，从这些起点开始向下搜索对象，搜索走过的路径，称为
引用链“，当一个对象到任意一个GC  Roots 对象没有任何引用链想链接时，（
从GC Roots到对象不可达时），证明对象已死。

Java中能作为GC Roots 的对象包含以下四种：
1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI(Native方法)引用的

5.垃圾回收算法：
5.1标记清除算法
思想：分为标记和清除两个阶段，标记阶段标记出此次垃圾回收需要回收的对象，清除阶段一次性清除所有带标记的对象。

问题：
1）效率：标记与清除的效率都不高
2）空间问题：标记清除算法会产生大量不连续的空间，若程序中需要分配大量连续对象时，由于空间碎片较多无法找到连续内存而不得不再次触发GC

5.2复制算法（新生代垃圾回收算法 ）
思想：将内存分为大小相等的两块，每次只使用其中一块内存，当使用的内存需要进行垃圾回收时会将此区域里的所有存活对象一次性复制到保留区域，然后将此内存一次性清理掉。

问题：
内存利用率太低。商用JVM都对复制算法做了改进。

JVM改进后的复制算法：

新生代中98%的对象都是“朝生夕死”（存活时间非常短），所以并不需要一比一划分内存空间。
将内存（新生代内存）分为一块较大的Eden（伊甸园）和两块较小的Survivor（幸存者，大学一样，一块称为From区，一块为To区）空间。每次只使用Eden和其中的一块Survivor区域。（默认为：8:1:1）

HotSpot复制算法流程：
1）当Eden区满的时候，会触发第一次Minor GC，将所有存活对象拷贝到Survivor的From区域，然后一次性清除Eden区。当Eden区再次触发MinorGC，会扫描Eden区和From区域，将两块空间中的存活对象拷贝到To区，而后一次性清除Eden区和Survivor区。
2）当后续Eden区再次发生Minor GC会对Eden区和To区进行回收，存活对象移动到From区，后续流程类似。只是将From区域和To区来回作为保留区域。
3）.部分对象会在From和To区域来回复制。如此交换15（MaxTenuringThreshold，默认为15次），最终会存入老年代。

Survivor区域无法存放所有存活对象，需要依赖其他内存（如老年代）进行分配担保（父债子偿的例子）。

5.3标记整理算法（老年代的垃圾回收（GC）算法）
老年代中的对象存活率较高，因此不适用复制算法（需要大量进行对象的复制过程，效率较低）

思想：算法分为标记与整理两个阶段。标记过程与比偶埃及清除过程一致，整理过程需要让所有存活对象向一端移动，而后直接清除掉存活对象边界以外的内存。

*********5.4分代回收算法（Java）*********
思想：根据对象的存活周期将内存划分为以下两块。
新生代：每次GC都有大部分对象死去，只有少量存活，因此采用复制算法。
老年代：随心的存活率较高，没有额外空间对其分配担保，采用标记-整理算法。

MinorGC      ，FullGC 
1.MInorGC称为新生代GC：指的是发生在新生代的垃圾回收，由于新生代对象大多数存活周期较短，因此  MinorGC发生频率非常频繁，一把回收速度也较高。
2.FullGC  称为老年代GC或者Major
GC：指的是发生在老年代的垃圾回收，出现MajorGC通常至少会伴随一次MinorGC（并非绝对），一般FullGC比MinorGC慢10倍以上，发生频率较低。

4.垃圾收集器（垃圾回收算法的具体体现）--JDK8

新生代垃圾回收器：
Serial（串行），ParNew（并行），Parallel    Scavenge（并行）


老年代垃圾回收器：
CMS（并发 ，第一款并发的垃圾回收器），Serial  Old（串行），Parallel  Old（并行）

全区域垃圾回收器：G1（并发）


串行：垃圾回收线程与用户线程在JVM 中顺序执行
并行：多个垃圾回收线程一起执行，用户线程仍处于等待状态
并发：垃圾回收线程和用户线程一起执行。
STW：当垃圾回收线程工作时，用户线程处于等待状态

6.对象分配策略
6.1对象有限分配在Eden分配
大多数情况下，对象在新生代Eden区分配空间，当Eden区没有足够的空间分配时，JVM发生一次MinorGC
-Xss：栈
-Xms
-Xmx
-Xmn:新生代内存大小


4.2大对象直接进入老年代 
-XX：PretenuraSizeThreshold=字节大小

4.3长期存活对象存入老年代
JVM给队里的每个对象定义了一个对象年龄计数器
若对象在Eden出生并且能被Survivor容纳，将此对象再每隔Survivor区域中经历一次MinorGC，年龄就增加一岁，当其年龄增加到一定程度（默认为15）此对象晋升为老年代。

-XXMaxTeuringThreshold

6.4 冬天年龄判定
JVM并不是永远要求对象的年龄必须到达MaxTenuringThreshold才能晋升老年代，若Survivor空间中相同年龄的所有对象大小 总和大于Survivor空间的一半，此时年龄大于等于该年龄的对象就可以进入老年代，无需等到MaxTenuringThreshold要求的年龄



7.1**********jps：进程状态工具************
列出正在运行的JVM 进程，并返回进程ID

jps -l ：输出主类 全名，返回进程ID



7.2jstat：JVM统计信息监视工具
显示本地或远程JVM中类装载，内存，垃圾回收等数据

jstat  -gcutil  PID：显示垃圾回收信息



7.3jinfo：JVM配置信息查看工具
jinfo  -flags  PID

默认JVM进程256M


**************7.4jmap*********
内存印象工具（查看Java堆具体信息）
jamp 用于生成堆转储快照（堆得快照）
jmap  -heap  PID:显示JVM堆得具体信息





7.5jhat：heap文件的分析工具
jhat  heap 文件路径


7.7*******jstack     Java栈跟踪工具******
jstack  生成当前JVM线程的快照
可用于定位线程出现长时间停顿的原因，如线程间死锁，死循环问题。


8.Java内存模型（JVM）--基于线程的内存模型

JVM定义的主要目的是为了定义持续中的各个变量的访问规则（JVM如何将变量从内存中取出以及将将变量写回内存的细节）此处的变量不包括实例字段，静态字段与数组元素。

8.1主内存（所有线程共享）与工作内存（每个线程独有）
JVM规定所有变量必须存储在内存中，每条线程都有自己的工作内容，线程的工作内存中保存了该线程使用到的变量的主内存副本。线程对变量的所有操作（读取，赋值等）都必须 在工作内存中进行，不能直接读写主内存变量，不同线程之间也不能直接访问彼此的工作空间，线程间变量值的传递均需要通过主
内存来完成。


8.2内存空间
Java内存模型的三大特性 :
1. 原子性 : 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和read。大致可以认为，基本数据类型的访问读写是具备原子性的。如若需要更大范围的原子性，需要内建锁或lock体系的支持，i++，i--等操作。(即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行)

原子性的：
int i=0;
i=3;
不是原子性的：
i++;
i--;
2. 可见性 : 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile、
synchronized、final三个关键字可以实现可见性。


3. 有序性 : 如果在本线程内观察，所有的操作都是有序的；如果在线程中观察另外一个线程，所有的操作都是无序的。前半句是指"线程内表现为串行"，后半句是指"指令重排序"和"工作内存与主内存同步延迟"现象。

JMM具备先天的有序性，即无需通过任何手段就能保证的有序性，称为JMM的happens-before 原则。若两个操作的次序无法从happens-before中推到出来，则无法保证其有序性，虚拟机可以随意地对它们进行重排序。


要想比并发程序的正确执行，必须同时保证原子性，可见性，以及有序性。只要有任何一个没有保证，就可能导致程序的运行不正确

下面就来具体介绍下happens-before原则（先行发生原则）：

1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
2.锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作
3.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
4传.递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
5.线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7.线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
8.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确


8.3volatile变量的特殊规则
第一：保证此变量堆所有线程的可见性。
当一个线程修改了这个变量的，新值对于其他线程来说是可以立即得知的。普通变量无法做到可见性。
volatile变量在各个线程中是一致的，但是volatile变量的运算在并发下执行是 一样不安全 的。Java中运算操作并非原子性操作，必须结合内建锁或者lock体系来约束。

由于volatile变量只保证可见性，在不符合以下两条规则的场景下，仍然需要使用加锁来保证原子性：
1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
2. 变量不需要与其他的状态变量共同参与不变约束

支持：int  x=0;

不支持：int  x=y;

并发场景下对于类似 i++操作如何保证程序的正确结果。
1.加锁 
2.使用原子类（Java.util.atomic包下的所有类--》内部使用CAS保证原子性）

a.当程序执行到volatile变量的读或者写操作时，在其前边的操作肯定会更改全部已经执行完毕且结果已经对后边操作可见，在其后边的操作肯定还没有执行。
b.在进行质量优化时，不能将volatile变量的访问语句放在后边执行，也不能提前执行。


懒汉式单例的线程安全问题：
singleton  =new singleton();
i=0;

1.在堆上分配空间
2.属性初始化
3.引用指向对象（singleton对象已经不为NULL）



