一.JVM简介
虚拟机：VMware/Virtual  Box
通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。


JVM是通过软件模拟Java字节码指令集，JVM只保存了PC寄存器，而普遍的虚拟机有很多寄存器。

从JDK1.3至今，HotSpot为默认JVM

JVM可以跑很多语言：Scala，Koltin

二.Java的内存区域划分---共六块内存


JVM内存划分－》判断对象是否存活－＞垃圾回收算法－》垃圾回收器－》JVM性能检测

3.1线程私有内存：每个线程都有，彼此之间完全隔离。
3.1.1程序计数器
程序计数器是比较小的内存空间，当前线程所执行的字节码的行号指示器。

字节码的行号指示器

单核CPU：每一个具体时刻只有一个线程抢占CPU资源。


若当前线程执行的是加Java方法，计数器记录的是正在执行的JVM字节码指令地址。
若当前线程执行的是native方法，计数器值为空。

程序计数器是唯一一块不会产生OOM异常的区域。

3.1.2虚拟机栈：Java方法执行的内存模型
虚拟机栈描述Java方法执行的内存模型。

每个方法的执行同时都会创建一个栈帧来存储局部变量表，操作数栈，方法出口等信息，每个方法从调用知道执行完毕的过程，对应一个栈帧在虚拟机的入栈和出栈过程。

生命周期与线程相同：在创建线程的同时创建线程的虚拟机栈，线程执行结束，虚拟机栈与线程一同被收回。


对象引用：四个字节

此区域一共会产生两种异常：
１.若线程请求的栈的深度大于JVM允许的深度（-Xss设置栈容量），抛出StackOverflowError异常。（递归，如果递归层数很深，会栈溢出）（常见于单线程）
２.虚拟机在进行栈的动态扩展时，若无法申请到足够内存，抛出OOM （OutOfMemoryError）异常　（常见于多线程 ）

3.1.3本地方法栈：
本地方法（native方法）执行的内存模型。

HotSpot虚拟机中，本地方法栈与虚拟机栈是同一块内存区域。


3.2线程共享内存：所有线程共享此内存空间，对空间所有的线程可见

3.2.1堆（GC堆）
Java堆（Java　Heap）是JVM管理的最大内存区域。在JVM启动时创建。所有线程共享此内存，此内存中存放的是对象实例以及数组。

Java堆是垃圾回收器管理的最主要的内存区域。Java堆可以处于物理上不连续的内存空间。
－Ｘｍｘ设置堆最大值
－Xms设置堆最小值

异常：
若在堆中没有足够的内存完成对象实例分配且堆无法再次扩展时。抛出OOM异常

OOM：

内存溢出：内存中的对象确实还应该存活，但是由于堆内存不够产生的异常。
内存泄漏：无用对象无法被GC


3.2.2方法区
用于存储JVM加载的类信息，常量，静态变量等数据。JDK１.８之前，方法区也叫永久代，JDK１.８之后称为元空间（Meta　Space）

方法区无法满足内存分配需求时，抛出OOM异常

3.2.3运行时常量池
运行时常量池方法区的一部分，存放字面量与符号引用。

字面量：字符串常量（JDK１.７移到堆中），final常量，基本数据类型的值。
符号引用：字段，类，方法的完全限定名（包名＋类名），名称，描述。

对象产生：符号引用－＞类－＞具体引用

4.判断对象是否存活
4.1引用计数法
算法思想：
给每一个对象附加一个引用计数器，每当有一个地方引用此对象，计数器加一，当有一个引用失效时，计数器减一。在任意时刻，只要计数器值为0,的对象就是不能再使用的，即对象已死。

引用计数法实现简单，效率也较高。Python使用引用计数法来管理内存。
但是无法解决循环引用问题。

JVM并没有采用此算法。

-XX：printGC：打印具体的垃圾回收日志

4.2可达性分析算法
Java采用可达性分析算法来判断对象是否存活）（C#，Lisp）
核心思想：
通过一系列“GC Roots”的对象作为起点，从这些起点开始向下搜索对象，搜索走过的路径，称为
引用链“，当一个对象到任意一个GC  Roots 对象没有任何引用链想链接时，（
从GC Roots到对象不可达时），证明对象已死。

Java中能作为GC Roots 的对象包含以下四种：
1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI(Native方法)引用的





