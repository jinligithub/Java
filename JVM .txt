一.JVM简介
虚拟机：VMware/Virtual  Box
通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。


JVM是通过软件模拟Java字节码指令集，JVM只保存了PC寄存器，而普遍的虚拟机有很多寄存器。

从JDK1.3至今，HotSpot为默认JVM

JVM可以跑很多语言：Scala，Koltin

二.Java的内存区域划分---共六块内存


JVM内存划分－》判断对象是否存活－＞垃圾回收算法－》垃圾回收器－》JVM性能检测

3.1线程私有内存：每个线程都有，彼此之间完全隔离。
3.1.1程序计数器
程序计数器是比较小的内存空间，当前线程所执行的字节码的行号指示器。

字节码的行号指示器

单核CPU：每一个具体时刻只有一个线程抢占CPU资源。


若当前线程执行的是加Java方法，计数器记录的是正在执行的JVM字节码指令地址。
若当前线程执行的是native方法，计数器值为空。

程序计数器是唯一一块不会产生OOM异常的区域。

3.1.2虚拟机栈：Java方法执行的内存模型
虚拟机栈描述Java方法执行的内存模型。

每个方法的执行同时都会创建一个栈帧来存储局部变量表，操作数栈，方法出口等信息，每个方法从调用知道执行完毕的过程，对应一个栈帧在虚拟机的入栈和出栈过程。

生命周期与线程相同：在创建线程的同时创建线程的虚拟机栈，线程执行结束，虚拟机栈与线程一同被收回。


对象引用：四个字节

此区域一共会产生两种异常：
１.若线程请求的栈的深度大于JVM允许的深度（-Xss设置栈容量），抛出StackOverflowError异常。（递归，如果递归层数很深，会栈溢出）（常见于单线程）
２.虚拟机在进行栈的动态扩展时，若无法申请到足够内存，抛出OOM （OutOfMemoryError）异常　（常见于多线程 ）

3.1.3本地方法栈：
本地方法（native方法）执行的内存模型。

HotSpot虚拟机中，本地方法栈与虚拟机栈是同一块内存区域。


3.2线程共享内存：所有线程共享此内存空间，对空间所有的线程可见

3.2.1堆（GC堆）
Java堆（Java　Heap）是JVM管理的最大内存区域。在JVM启动时创建。所有线程共享此内存，此内存中存放的是对象实例以及数组。

Java堆是垃圾回收器管理的最主要的内存区域。Java堆可以处于物理上不连续的内存空间。
－Ｘｍｘ设置堆最大值
－Xms设置堆最小值

异常：
若在堆中没有足够的内存完成对象实例分配且堆无法再次扩展时。抛出OOM异常

OOM：

内存溢出：内存中的对象确实还应该存活，但是由于堆内存不够产生的异常。
内存泄漏：无用对象无法被GC


3.2.2方法区
用于存储JVM加载的类信息，常量，静态变量等数据。JDK１.８之前，方法区也叫永久代，JDK１.８之后称为元空间（Meta　Space）

方法区无法满足内存分配需求时，抛出OOM异常

3.2.3运行时常量池
运行时常量池方法区的一部分，存放字面量与符号引用。

字面量：字符串常量（JDK１.７移到堆中），final常量，基本数据类型的值。
符号引用：字段，类，方法的完全限定名（包名＋类名），名称，描述。

对象产生：符号引用－＞类－＞具体引用

4.判断对象是否存活
4.1引用计数法
算法思想：
给每一个对象附加一个引用计数器，每当有一个地方引用此对象，计数器加一，当有一个引用失效时，计数器减一。在任意时刻，只要计数器值为0,的对象就是不能再使用的，即对象已死。

引用计数法实现简单，效率也较高。Python使用引用计数法来管理内存。
但是无法解决循环引用问题。

JVM并没有采用此算法。

-XX：printGC：打印具体的垃圾回收日志

4.2可达性分析算法
Java采用可达性分析算法来判断对象是否存活）（C#，Lisp）
核心思想：
通过一系列“GC Roots”的对象作为起点，从这些起点开始向下搜索对象，搜索走过的路径，称为
引用链“，当一个对象到任意一个GC  Roots 对象没有任何引用链想链接时，（
从GC Roots到对象不可达时），证明对象已死。

Java中能作为GC Roots 的对象包含以下四种：
1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI(Native方法)引用的

5.垃圾回收算法：
5.1标记清除算法
思想：分为标记和清除两个阶段，标记阶段标记出此次垃圾回收需要回收的对象，清除阶段一次性清除所有带标记的对象。

问题：
1）效率：标记与清除的效率都不高
2）空间问题：标记清除算法会产生大量不连续的空间，若程序中需要分配大量连续对象时，由于空间碎片较多无法找到连续内存而不得不再次触发GC

5.2复制算法（新生代垃圾回收算法 ）
思想：将内存分为大小相等的两块，每次只使用其中一块内存，当使用的内存需要进行垃圾回收时会将此区域里的所有存活对象一次性复制到保留区域，然后将此内存一次性清理掉。

问题：
内存利用率太低。商用JVM都对复制算法做了改进。

JVM改进后的复制算法：

新生代中98%的对象都是“朝生夕死”（存活时间非常短），所以并不需要一比一划分内存空间。
将内存（新生代内存）分为一块较大的Eden（伊甸园）和两块较小的Survivor（幸存者，大学一样，一块称为From区，一块为To区）空间。每次只使用Eden和其中的一块Survivor区域。（默认为：8:1:1）

HotSpot复制算法流程：
1）当Eden区满的时候，会触发第一次Minor GC，将所有存活对象拷贝到Survivor的From区域，然后一次性清除Eden区。当Eden区再次触发MinorGC，会扫描Eden区和From区域，将两块空间中的存活对象拷贝到To区，而后一次性清除Eden区和Survivor区。
2）当后续Eden区再次发生Minor GC会对Eden区和To区进行回收，存活对象移动到From区，后续流程类似。只是将From区域和To区来回作为保留区域。
3）.部分对象会在From和To区域来回复制。如此交换15（MaxTenuringThreshold，默认为15次），最终会存入老年代。

Survivor区域无法存放所有存活对象，需要依赖其他内存（如老年代）进行分配担保（父债子偿的例子）。

5.3标记整理算法（老年代的垃圾回收（GC）算法）
老年代中的对象存活率较高，因此不适用复制算法（需要大量进行对象的复制过程，效率较低）

思想：算法分为标记与整理两个阶段。标记过程与比偶埃及清除过程一致，整理过程需要让所有存活对象向一端移动，而后直接清除掉存活对象边界以外的内存。

*********5.4分代回收算法（Java）*********
思想：根据对象的存活周期将内存划分为以下两块。
新生代：每次GC都有大部分对象死去，只有少量存活，因此采用复制算法。
老年代：随心的存活率较高，没有额外空间对其分配担保，采用标记-整理算法。

MinorGC      ，FullGC 
1.MInorGC称为新生代GC：指的是发生在新生代的垃圾回收，由于新生代对象大多数存活周期较短，因此  MinorGC发生频率非常频繁，一把回收速度也较高。
2.FullGC  称为老年代GC或者Major
GC：指的是发生在老年代的垃圾回收，出现MajorGC通常至少会伴随一次MinorGC（并非绝对），一般FullGC比MinorGC慢10倍以上，发生频率较低。

4.垃圾收集器（垃圾回收算法的具体体现）--JDK8

新生代垃圾回收器：
Serial（串行），ParNew（并行），Parallel    Scavenge（并行）


老年代垃圾回收器：
CMS（并发 ，第一款并发的垃圾回收器），Serial  Old（串行），Parallel  Old（并行）

全区域垃圾回收器：G1（并发）


串行：垃圾回收线程与用户线程在JVM 中顺序执行
并行：多个垃圾回收线程一起执行，用户线程仍处于等待状态
并发：垃圾回收线程和用户线程一起执行。
STW：当垃圾回收线程工作时，用户线程处于等待状态

6.对象分配策略
6.1对象有限分配在Eden分配
大多数情况下，对象在新生代Eden区分配空间，当Eden区没有足够的空间分配时，JVM发生一次MinorGC
-Xss：栈
-Xms
-Xmx
-Xmn:新生代内存大小


4.2大对象直接进入老年代 
-XX：PretenuraSizeThreshold=字节大小

4.3长期存活对象存入老年代
JVM给队里的每个对象定义了一个对象年龄计数器
若对象在Eden出生并且能被Survivor容纳，将此对象再每隔Survivor区域中经历一次MinorGC，年龄就增加一岁，当其年龄增加到一定程度（默认为15）此对象晋升为老年代。

-XXMaxTeuringThreshold

6.4 冬天年龄判定
JVM并不是永远要求对象的年龄必须到达MaxTenuringThreshold才能晋升老年代，若Survivor空间中相同年龄的所有对象大小 总和大于Survivor空间的一半，此时年龄大于等于该年龄的对象就可以进入老年代，无需等到MaxTenuringThreshold要求的年龄



7.1**********jps：进程状态工具************
列出正在运行的JVM 进程，并返回进程ID

jps -l ：输出主类 全名，返回进程ID



7.2jstat：JVM统计信息监视工具
显示本地或远程JVM中类装载，内存，垃圾回收等数据

jstat  -gcutil  PID：显示垃圾回收信息



7.3jinfo：JVM配置信息查看工具
jinfo  -flags  PID

默认JVM进程256M


**************7.4jmap**********



