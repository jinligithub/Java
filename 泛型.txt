1.5JDK新特性
1.1的可变参数
设计一个

可变参数语法
数据类型  ...   可变参数名称
int ... data

可变参数的实质还是数组
一个方法中只允许一个可变参数，并且可变参数一定是方法最后一个参数


1.2foreach循环
只用于数组，类集内容的取得，不得修改原数组，类集内容
for（数据类型  临时变量：数组名 /类集名）
for( int temp: data){}

1.3静态导入
将一个类中所有的静态域（包含静态属性，方法），全部导入到使用类中，此时调用属性和方法不在
需要类名
Ctrl+Alt+O：自动导入包自动删除包

2.泛型---守门员（安全性考虑，不再有类型转换异常），Java语法糖

2.1泛型类
所谓的泛型指得是在定义时不会设置类中属性或方法参数的具体类型，而是在类使用时在定义

 语法：
class  MyClass<T>{
       T  t; 
 }
<>中的T被称为类型参数，用于指代任何类型。<>不可省
规范起见，类型参数一半由单个大写字母表示。

T：用在泛型类声明上，指代泛型类
E：一半用于属性
K,V：键值对
当泛型类中需要多个不同类型变量时，<>以"，"分割声明不同大写字母即可
class  MyClass<T.E> {
    T  t;
    E  e;
}
泛型的出现彻底解决了向下转型带来的ClassCastExcepti是on 问题
泛型只能使用引用数据类型，基本数据类型使用包装类
2.2泛型方法

语法：
public <T> void method(T,t){} 

当泛型类和泛型方法共存时，泛型方法中的类型参数类型和泛型类的参数无关，泛型方法始终以自己的类型参数为准。
规范起见：当泛型类与泛型方法共存时，请 使用不同的字母代替

2.3通配符---解决泛型参数统一化问题
2.3.1   ？通配符  作用于方法参数声明
public static void print(MyClass <?> myclass)

此时方法参数表示可以接收任何类型的MyClass对象
由于无法确定入参的类型，因此“？”通配符下的泛型参数，只能取得类中属性值，无法进行属性设置。

2.3.2设置泛型的上限---用于泛型类的声明，也可用于方法参数，
泛型类声明：T  extends   类
方法参数：？extends  类
eg:  ？ extends  Number;
表示方法入参只能接受Number（父类）以及其子类对象
方法参数设置泛型上限任然只能取得类中的属性值，而无法设置值，因为设置值子类不一定能使用（父类不一定能发生向下转型变为之类）

2.3.3设置泛型下限--只能用于方法参数
？ super 类（>=类）

表示方法入参只能接收类以及其父类对象

方法参数设置泛型下限不仅可以取得类中的属性值，还可以设置属性值，因为之类可以天然向上转型变为父类。

2.4泛型接口

1.之类在接口继续保留泛型
class InterfaceImpl<T> implements  IInterface<T>{}
2.子类实现接口时就确定好类型
class InterfaceImpl<T> implements  IInterface<String>{}

2.5 泛型察除
泛型信息仅存在于代码阶段，进入JVM之前，与泛型相关信息会被察除掉，专业术语就叫类型察除。换句话，泛型类与普通类在JVM中没有任何区别。
泛型类进入JVM之前会进行类型察除，泛型类的类型参数如果没有指定类型上限，则察除成为Object类。如果类型参数指定类型上限，则察除为相应类型上限。

<T> ->Object
<T  extends  String> ->String


















